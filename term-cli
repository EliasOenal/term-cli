#!/usr/bin/env python3
# term-cli — Elias Oenal <termcli@eliasoenal.com>
#
# Copyright (c) 2026 Elias Oenal <termcli@eliasoenal.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted (subject to the limitations in the disclaimer
# below) provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of term-cli nor the names of its contributors may be used
#   to endorse or promote products derived from this software without specific
#   prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY
# THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
# NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
term-cli — Non-interactive terminal session control for AI agents (tmux wrapper)

Wraps tmux to provide a stable API for automation. Never attaches or enters interactive UI.

Requires: tmux on PATH (macOS: brew install tmux)

Defaults: 80x24 terminal, visible screen only, trailing whitespace trimmed

Env vars: TERM_CLI_COLS, TERM_CLI_ROWS override default size

Exit codes: 0=success, 1=runtime error, 2=invalid input, 3=timeout, 4=detached, 5=locked, 127=tmux not found

tmux keys: C-c C-d C-u C-z (ctrl), Enter Escape Space Tab BSpace, Up Down Left Right,
           Home End NPage PPage, F1-F12

Quick reference:
  term-cli start --session NAME [--cols 80] [--rows 24] [--cwd DIR] [--locked]
  term-cli run --session NAME "cmd" [--wait] [--timeout 10]
  term-cli capture --session NAME [--scrollback N] [--tail N]
  term-cli send-key --session NAME KEY
  term-cli send-text --session NAME "text" [--enter]
  term-cli send-stdin --session NAME < file.txt
  term-cli wait --session NAME [--timeout 10]
  term-cli wait-idle --session NAME [--seconds 2] [--timeout 10]
  term-cli wait-for --session NAME PATTERN [--timeout 10] [--ignore-case] [--capture]
  term-cli status --session NAME
  term-cli resize --session NAME [--cols N] [--rows N]
  term-cli pipe-log --session NAME FILE [--raw]
  term-cli unpipe --session NAME
  term-cli kill --session NAME [--force]
  term-cli list

Locked sessions (human controls, agent observes):
  When a session is locked, the agent can only use: capture, status, wait-*, request*, list, scroll, pipe-log, unpipe
  Locked commands (run, send-*, kill, resize) return exit code 5.

Human assistance (request/response):
  term-cli request --session NAME --message "help needed"
  term-cli request-wait --session NAME [--timeout 300]
  term-cli request-cancel --session NAME
  term-cli request-status --session NAME

Note: wait-for searches the entire visible screen, including the command echo line.

Short flags: -s (session), -w (wait), -t (timeout/tail), -x (cols), -y (rows),
             -c (cwd), -n (scrollback), -e (enter/env), -r (raw), -i (idle seconds/ignore-case),
             -m (message), -f (force), -l (locked)
"""

from __future__ import annotations

import argparse
import os
import shlex
import shutil
import subprocess
import sys
import time
from dataclasses import dataclass
from datetime import datetime
from typing import Any

DEFAULT_COLS = 80
DEFAULT_ROWS = 24
DEFAULT_WAIT_TIMEOUT = 10.0
DEFAULT_IDLE_SECONDS = 2.0
DEFAULT_IDLE_TIMEOUT = 10.0
DEFAULT_REQUEST_TIMEOUT = 300.0

# Polling configuration for wait operations
POLL_INTERVAL_INITIAL = 0.1      # Starting poll interval in seconds
POLL_INTERVAL_MAX = 0.5          # Maximum poll interval (caps gradual increase)
POLL_INTERVAL_MULTIPLIER = 1.2   # Factor to increase poll interval each iteration

# Prompt detection configuration
PROMPT_CHARS = frozenset('$%#>)]:')  # Characters that indicate end of prompt
STABILITY_SAMPLES = 3                 # Number of samples for stability check
STABILITY_INTERVAL = 0.05             # Interval between stability samples (50ms)

# tmux user option for human assistance requests (using @ prefix for user options)
# User options can be used directly in tmux format strings with #{@name} syntax
TERM_CLI_REQUEST_OPT = "@term_cli_request"
# tmux user option for human response messages
TERM_CLI_RESPONSE_OPT = "@term_cli_response"
# tmux user option to signal human detached without completing request
TERM_CLI_DETACHED_OPT = "@term_cli_detached"
# tmux user option to lock session (agent can only observe, not interact)
TERM_CLI_LOCKED_OPT = "@term_cli_agent_locked"

# Global tmux socket name (set via -L/--socket-name option)
_tmux_socket: str | None = None

# Exit codes
EXIT_SUCCESS = 0
EXIT_RUNTIME_ERROR = 1    # RuntimeError - operation failed
EXIT_INPUT_ERROR = 2      # ValueError - invalid input
EXIT_TIMEOUT = 3          # Timeout waiting for condition
EXIT_DETACHED = 4         # Human detached without completing request
EXIT_LOCKED = 5           # Session is locked (agent read-only)
EXIT_NOT_FOUND = 127      # FileNotFoundError - missing dependency


class OperationTimeout(Exception):
    """Raised when an operation times out waiting for a condition."""
    pass


class HumanDetached(Exception):
    """Raised when human detaches from session without completing request."""
    pass


class AgentLocked(Exception):
    """Raised when agent tries to interact with a locked session."""
    pass


class QueryResult(Exception):
    """Non-error result requiring a specific exit code (e.g., query returned 'not found')."""
    def __init__(self, message: str, exit_code: int = EXIT_RUNTIME_ERROR) -> None:
        super().__init__(message)
        self.exit_code = exit_code

# ----------------------------
# Utilities
# ----------------------------

def _eprint(*args: Any) -> None:
    print(*args, file=sys.stderr)

def _tmux_path() -> str:
    p = shutil.which("tmux")
    if not p:
        raise FileNotFoundError("tmux not found on PATH. Install tmux (macOS: `brew install tmux`).")
    return p

@dataclass
class CmdResult:
    ok: bool
    code: int
    stdout: str
    stderr: str

def _run_tmux(args: list[str]) -> CmdResult:
    tmux = _tmux_path()
    cmd_args = list(args)
    if _tmux_socket:
        cmd_args = ["-L", _tmux_socket] + cmd_args
    proc = subprocess.run(
        [tmux, *cmd_args],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    return CmdResult(ok=(proc.returncode == 0), code=proc.returncode, stdout=proc.stdout, stderr=proc.stderr)

def _session_exists(session: str) -> bool:
    res = _run_tmux(["has-session", "-t", session])
    return res.ok

def _require_session(session: str) -> None:
    if not _session_exists(session):
        raise ValueError(f"Session '{session}' does not exist. Create it with: term-cli start --session {session}")

def _env_int(name: str) -> int | None:
    v = os.environ.get(name)
    if v is None or v.strip() == "":
        return None
    try:
        return int(v)
    except ValueError:
        raise ValueError(f"Environment variable {name} must be an integer, got: {v!r}")

def _shlex_quote(s: str) -> str:
    return shlex.quote(s)

def _size_defaults() -> tuple[int, int]:
    cols = _env_int("TERM_CLI_COLS")
    rows = _env_int("TERM_CLI_ROWS")
    return (cols if cols is not None else DEFAULT_COLS,
            rows if rows is not None else DEFAULT_ROWS)

def _trim_output(text: str) -> str:
    """Remove trailing whitespace and blank lines."""
    lines = text.rstrip().split('\n')
    # Remove trailing empty lines
    while lines and not lines[-1].strip():
        lines.pop()
    return '\n'.join(lines)

def _get_pane_dimensions(session: str) -> tuple[int, int]:
    """Get current pane width and height."""
    res = _run_tmux(["display-message", "-p", "-t", session, "#{pane_width}\t#{pane_height}"])
    if not res.ok:
        return (DEFAULT_COLS, DEFAULT_ROWS)
    parts = res.stdout.strip().split('\t')
    try:
        return (int(parts[0]), int(parts[1]))
    except (IndexError, ValueError):
        return (DEFAULT_COLS, DEFAULT_ROWS)

def _capture_screen(session: str, trim: bool = True, raw: bool = False, 
                    join_wrapped: bool = False) -> str:
    """Capture only the visible screen content (not scrollback).
    
    Args:
        session: tmux session name
        trim: Remove trailing whitespace and blank lines
        raw: Include ANSI escape sequences
        join_wrapped: Join wrapped lines (-J flag). Default False to preserve
                      physical screen layout. Set True for logical line capture
                      (e.g., scrollback).
    """
    # -p prints to stdout, -J joins wrapped lines, -e includes escape sequences (colors)
    tmux_args = ["capture-pane", "-p", "-t", session]
    if join_wrapped:
        tmux_args.insert(2, "-J")
    if raw:
        tmux_args.insert(2, "-e")  # Add -e flag for escape sequences
    res = _run_tmux(tmux_args)
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to capture pane")
    output = res.stdout
    if trim:
        output = _trim_output(output)
    return output

def _get_cursor_position(session: str) -> tuple[int, int] | None:
    """Get cursor position (x, y) in the pane. Returns None on failure."""
    res = _run_tmux(["display-message", "-t", session, "-p", "#{cursor_x}\t#{cursor_y}"])
    if not res.ok:
        return None
    try:
        parts = res.stdout.strip().split('\t')
        return (int(parts[0]), int(parts[1]))
    except (ValueError, IndexError):
        return None

def _cursor_at_prompt(line: str, cursor_x: int) -> bool:
    """Check if cursor is positioned at a prompt on this line.
    
    Simple check based on cursor position:
    1. Position cursor_x - 1: must be non-existent OR whitespace
    2. Position cursor_x - 2: must be a prompt char ($%#>)]:)
    
    This ensures we match prompts like "$ ", "(lldb) ", ">>> " where the cursor
    sits right after the prompt character and optional space.
    """
    # Need cursor at least at position 2 for "prompt_char + space + cursor"
    if cursor_x < 2:
        return False
    
    # Position cursor_x - 1: must not exist or be whitespace
    if cursor_x - 1 < len(line):
        char_left_1 = line[cursor_x - 1]
        if char_left_1 not in ' \t':
            return False  # Non-whitespace immediately left of cursor
    
    # Position cursor_x - 2: must be a prompt char
    if cursor_x - 2 >= len(line):
        return False  # Line too short
    char_left_2 = line[cursor_x - 2]
    if char_left_2 not in PROMPT_CHARS:
        return False
    
    return True


def _check_stability(session: str) -> bool:
    """Check if screen remains stable (unchanged) across multiple samples.
    
    Takes STABILITY_SAMPLES screen captures with STABILITY_INTERVAL between them.
    Returns True only if all samples are identical.
    """
    prev_screen = _capture_screen(session, trim=False, join_wrapped=False)
    
    for _ in range(STABILITY_SAMPLES - 1):
        time.sleep(STABILITY_INTERVAL)
        curr_screen = _capture_screen(session, trim=False, join_wrapped=False)
        if curr_screen != prev_screen:
            return False
        prev_screen = curr_screen
    
    return True


def _is_at_prompt(session: str) -> bool:
    """Check if the terminal is at a shell prompt, ready for input.
    
    Uses cursor position + prompt pattern + stability check:
    1. Get the line where cursor is located
    2. Check if that line ends with 'prompt_char + space' and cursor is at end
    3. Verify screen is stable (not actively scrolling output)
    
    This handles:
    - Standard shells (bash, zsh) and REPLs (python, node)
    - Debuggers with status bars (lldb, gdb) where prompt is above status line
    - Avoids false positives from scrolling output containing prompt-like chars
    """
    # Use join_wrapped=False so line numbers match cursor position
    screen = _capture_screen(session, trim=False, join_wrapped=False)
    if not screen:
        return False
    
    cursor_pos = _get_cursor_position(session)
    if cursor_pos is None:
        return False
    cursor_x, cursor_y = cursor_pos
    
    lines = screen.split('\n')
    
    # Get the line where cursor is located
    if cursor_y >= len(lines):
        return False
    cursor_line = lines[cursor_y]
    
    # Check if cursor is at a prompt on this line
    if not _cursor_at_prompt(cursor_line, cursor_x):
        return False
    
    # Stability check: screen must remain unchanged across multiple samples
    # This prevents false positives from output scrolling by with prompt-like chars
    return _check_stability(session)

def _wait_for_prompt(session: str, timeout: float) -> tuple[bool, float]:
    """Wait for shell prompt to appear. Returns (success, elapsed_time).
    
    Polls _is_at_prompt which includes a stability check, so this function
    simply loops until prompt is detected or timeout is reached.
    """
    start = time.time()
    poll_interval = POLL_INTERVAL_INITIAL
    
    while True:
        if _is_at_prompt(session):
            return (True, time.time() - start)
        if time.time() - start >= timeout:
            return (False, time.time() - start)
        time.sleep(poll_interval)
        # Increase poll interval gradually to reduce overhead
        if poll_interval < POLL_INTERVAL_MAX:
            poll_interval = min(poll_interval * POLL_INTERVAL_MULTIPLIER, POLL_INTERVAL_MAX)

def _wait_for_idle(session: str, idle_seconds: float, timeout: float) -> tuple[bool, float]:
    """Wait until no output for idle_seconds. Returns (success, elapsed_time)."""
    start = time.time()
    last_content = _capture_screen(session, trim=False)
    last_change = time.time()
    poll_interval = POLL_INTERVAL_INITIAL
    
    while True:
        current_content = _capture_screen(session, trim=False)
        if current_content != last_content:
            last_content = current_content
            last_change = time.time()
            # Reset poll interval when content changes (activity detected)
            poll_interval = POLL_INTERVAL_INITIAL
        
        idle_time = time.time() - last_change
        if idle_time >= idle_seconds:
            return (True, time.time() - start)
        
        elapsed = time.time() - start
        if elapsed >= timeout:
            return (False, elapsed)
        
        time.sleep(poll_interval)
        # Increase poll interval gradually to reduce CPU usage during long waits
        if poll_interval < POLL_INTERVAL_MAX:
            poll_interval = min(poll_interval * POLL_INTERVAL_MULTIPLIER, POLL_INTERVAL_MAX)

# ----------------------------
# Commands
# ----------------------------

def cmd_list(args: argparse.Namespace) -> None:
    res = _run_tmux(["list-sessions", "-F", "#{session_name}"])
    if not res.ok:
        # "no server running" when server exists but has no sessions
        # "error connecting" when socket doesn't exist yet
        if "no server running" in res.stderr.lower() or "error connecting" in res.stderr.lower():
            return  # No sessions, print nothing
        raise RuntimeError(res.stderr.strip() or "Failed to list sessions")
    sessions = [line.strip() for line in res.stdout.splitlines() if line.strip()]
    for s in sessions:
        locked_indicator = " [LOCKED]" if _is_locked(s) else ""
        print(f"{s}{locked_indicator}")

def cmd_start(args: argparse.Namespace) -> None:
    session = args.session
    if _session_exists(session):
        raise RuntimeError(f"Session '{session}' already exists (use 'kill' first to replace)")

    # Validate env vars early
    if args.env:
        for kv in args.env:
            if "=" not in kv:
                raise ValueError(f"--env must be KEY=VALUE, got: {kv}")

    # Validate cwd exists
    if args.cwd:
        if not os.path.isdir(args.cwd):
            raise ValueError(f"--cwd directory does not exist: {args.cwd}")

    # Validate shell exists and is executable
    if args.shell:
        if not os.path.isfile(args.shell):
            raise ValueError(f"--shell does not exist: {args.shell}")
        if not os.access(args.shell, os.X_OK):
            raise ValueError(f"--shell is not executable: {args.shell}")

    cols_default, rows_default = _size_defaults()
    cols = args.cols if args.cols is not None else cols_default
    rows = args.rows if args.rows is not None else rows_default

    tmux_args = ["new-session", "-d", "-s", session]

    if args.cwd:
        tmux_args += ["-c", args.cwd]

    if not args.no_size:
        tmux_args += ["-x", str(cols), "-y", str(rows)]

    # Pass env vars directly to new-session so the shell inherits them
    if args.env:
        for kv in args.env:
            tmux_args += ["-e", kv]

    if args.shell:
        tmux_args += [args.shell]

    res = _run_tmux(tmux_args)
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to start session")

    # Workaround: some tmux versions ignore -x/-y on new-session -d when
    # window-size is manual, so enforce size with resize-window after creation.
    if not args.no_size:
        _run_tmux(["resize-window", "-t", session, "-x", str(cols), "-y", str(rows)])

    # Set locked flag if requested
    if args.locked:
        _set_locked(session)

    size_info = f" ({cols}x{rows})" if not args.no_size else ""
    cwd_info = f" in {args.cwd}" if args.cwd else ""
    locked_info = " [LOCKED]" if args.locked else ""
    print(f"Created session '{session}'{size_info}{cwd_info}{locked_info}")

def _list_sessions() -> list[str]:
    """Return list of all session names, or empty list if none exist."""
    res = _run_tmux(["list-sessions", "-F", "#{session_name}"])
    if not res.ok:
        # "no server running" when server exists but has no sessions
        # "error connecting" when socket doesn't exist yet
        if "no server running" in res.stderr.lower() or "error connecting" in res.stderr.lower():
            return []
        raise RuntimeError(res.stderr.strip() or "Failed to list sessions")
    return [line.strip() for line in res.stdout.splitlines() if line.strip()]

def cmd_kill(args: argparse.Namespace) -> None:
    if args.all and args.session:
        raise ValueError("Cannot use --all with --session")
    if not args.all and not args.session:
        raise ValueError("Either --session or --all is required")

    if args.all:
        sessions = _list_sessions()
        if not sessions:
            print("No sessions to kill")
            return
        for session in sessions:
            _require_unlocked(session)
        # Validate all unattached (unless force)
        if not args.force:
            for session in sessions:
                attached = _get_session_attached_count(session)
                if attached > 0:
                    raise RuntimeError(
                        f"Session '{session}' has {attached} attached client(s). "
                        f"Use --force to kill anyway."
                    )
        # All validated, proceed with kill
        for session in sessions:
            res = _run_tmux(["kill-session", "-t", session])
            if not res.ok:
                raise RuntimeError(res.stderr.strip() or f"Failed to kill session '{session}'")
            print(f"Killed session '{session}'")
        return

    session = args.session
    if not _session_exists(session):
        raise RuntimeError(f"Session '{session}' does not exist")
    _require_unlocked(session)
    
    # Check for attached humans (unless force)
    if not args.force:
        attached = _get_session_attached_count(session)
        if attached > 0:
            raise RuntimeError(
                f"Session '{session}' has {attached} attached client(s). "
                f"Use --force to kill anyway."
            )
    
    res = _run_tmux(["kill-session", "-t", session])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to kill session")
    print(f"Killed session '{session}'")

def cmd_send_text(args: argparse.Namespace) -> None:
    """Send literal text to the session. Optionally send Enter after."""
    session = args.session
    _require_session(session)
    _require_unlocked(session)

    res = _run_tmux(["send-keys", "-t", session, "--", args.text])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to send text")

    if args.enter:
        res2 = _run_tmux(["send-keys", "-t", session, "Enter"])
        if not res2.ok:
            raise RuntimeError(res2.stderr.strip() or "Failed to send Enter")

def cmd_send_key(args: argparse.Namespace) -> None:
    """Send a tmux key (e.g., C-c, Enter, Up) to the session."""
    session = args.session
    _require_session(session)
    _require_unlocked(session)

    res = _run_tmux(["send-keys", "-t", session, args.key])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to send key")


def cmd_send_stdin(args: argparse.Namespace) -> None:
    """Send content from stdin to the session via tmux paste buffer."""
    session = args.session
    _require_session(session)
    _require_unlocked(session)

    # Read from stdin
    if sys.stdin.isatty():
        raise ValueError("No input provided. Usage: term-cli send-stdin -s NAME < file.txt")
    
    content = sys.stdin.read()
    if not content:
        raise ValueError("Empty input provided")
    
    # Use tmux load-buffer to load content, then paste-buffer to send it
    # load-buffer - reads from stdin when - is specified
    tmux = _tmux_path()
    tmux_args = [tmux]
    if _tmux_socket:
        tmux_args.extend(["-L", _tmux_socket])
    tmux_args.extend(["load-buffer", "-"])
    proc = subprocess.run(
        tmux_args,
        input=content,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    if proc.returncode != 0:
        raise RuntimeError(proc.stderr.strip() or "Failed to load buffer")
    
    # Paste buffer into the session
    res = _run_tmux(["paste-buffer", "-t", session])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to paste buffer")
    
    # Clean up the buffer
    _run_tmux(["delete-buffer"])
    
    lines = content.count('\n')
    chars = len(content)
    print(f"Sent {chars} chars ({lines} lines) to '{session}'")


def cmd_run(args: argparse.Namespace) -> None:
    """Send a command + Enter to the session. Optionally wait for prompt to return."""
    session = args.session
    _require_session(session)
    _require_unlocked(session)

    res = _run_tmux(["send-keys", "-t", session, "--", args.command])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to send command")
    res2 = _run_tmux(["send-keys", "-t", session, "Enter"])
    if not res2.ok:
        raise RuntimeError(res2.stderr.strip() or "Failed to send Enter")

    if args.wait:
        # Brief delay to let command start executing
        time.sleep(0.1)
        timeout = args.timeout if args.timeout is not None else DEFAULT_WAIT_TIMEOUT
        success, elapsed = _wait_for_prompt(session, timeout)
        if success:
            print(f"Command completed ({elapsed:.1f}s)")
        else:
            raise OperationTimeout(f"command not completed after {timeout}s (may still be running)")
    else:
        if args.timeout is not None:
            _eprint("Warning: --timeout has no effect without --wait")

def cmd_capture(args: argparse.Namespace) -> None:
    """Capture and print the terminal screen content."""
    session = args.session
    _require_session(session)

    trim = not args.no_trim
    raw = args.raw
    scrollback: int | None = args.scrollback
    tail: int | None = args.tail

    if scrollback is not None and tail is not None:
        raise ValueError("--scrollback and --tail are mutually exclusive")

    if scrollback is not None:
        if scrollback <= 0:
            raise ValueError(f"--scrollback must be positive, got: {scrollback}")
        # Capture scrollback history with -J (join wrapped lines for logical lines).
        # Use a generous -S to grab more than needed, then truncate to exactly N lines.
        tmux_args = ["capture-pane", "-p", "-J", "-t", session, "-S", f"-{scrollback}"]
        if raw:
            tmux_args.insert(2, "-e")
        res = _run_tmux(tmux_args)
        if not res.ok:
            raise RuntimeError(res.stderr.strip() or "Failed to capture pane")
        output = res.stdout
        if trim:
            output = _trim_output(output)
        # Truncate to exactly N logical lines (tmux may return more due to
        # -S being physical-row-based while -J joins wrapped lines).
        lines = output.split('\n')
        if len(lines) > scrollback:
            lines = lines[-scrollback:]
        output = '\n'.join(lines)
    elif tail is not None:
        if tail <= 0:
            raise ValueError(f"--tail must be positive, got: {tail}")
        # Capture visible screen without -J (preserve physical rows),
        # then take the last N rows.
        output = _capture_screen(session, trim=trim, raw=raw, join_wrapped=False)
        lines = output.split('\n')
        if len(lines) > tail:
            lines = lines[-tail:]
        output = '\n'.join(lines)
    else:
        # Capture only visible screen (no -J, physical rows preserved)
        output = _capture_screen(session, trim=trim, raw=raw)

    print(output)

def cmd_pipe_log(args: argparse.Namespace) -> None:
    """Stream terminal output to a log file (ANSI escapes stripped by default)."""
    session = args.session
    _require_session(session)

    logfile = os.path.abspath(args.file)
    
    # Validate parent directory exists
    parent_dir = os.path.dirname(logfile)
    if parent_dir and not os.path.isdir(parent_dir):
        raise ValueError(f"Parent directory does not exist: {parent_dir}")
    
    if args.raw:
        # Raw output including escape codes
        shell_cmd = f"cat >> {_shlex_quote(logfile)}"
    else:
        # Strip ANSI escape codes using perl (more comprehensive than sed)
        # Handles: CSI sequences, OSC sequences, bracketed paste mode, etc.
        # Use unbuffered mode for real-time output
        strip_cmd = r"perl -pe 'BEGIN{$|=1} s/\x1b\[[0-9;]*[a-zA-Z]|\x1b\][^\x07]*\x07|\x1b\[\?[0-9;]*[hl]//g'"
        shell_cmd = f"{strip_cmd} >> {_shlex_quote(logfile)}"
    
    res = _run_tmux(["pipe-pane", "-o", "-t", session, shell_cmd])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to pipe pane")
    
    mode = "raw" if args.raw else "clean"
    print(f"Piping output to {logfile} ({mode})")

def cmd_unpipe(args: argparse.Namespace) -> None:
    """Stop streaming output to a log file."""
    session = args.session
    _require_session(session)

    res = _run_tmux(["pipe-pane", "-t", session])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to stop piping")
    print(f"Stopped piping output")

def _get_process_tree(pane_pid: int) -> list[tuple[int, int, str, str]]:
    """Get all descendant processes of the pane shell.
    
    Returns list of (pid, ppid, stat, command) tuples for all descendants.
    Uses portable POSIX ps command.
    """
    # Get all processes with pid, ppid, stat, command
    proc = subprocess.run(
        ["ps", "-eo", "pid,ppid,stat,comm"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    if proc.returncode != 0:
        return []
    
    # Parse output and find descendants
    descendants = []
    known_pids = {pane_pid}
    
    # Parse all lines first
    all_procs = []
    for line in proc.stdout.strip().split('\n')[1:]:  # Skip header
        parts = line.split()
        if len(parts) >= 4:
            try:
                pid = int(parts[0])
                ppid = int(parts[1])
                stat = parts[2]
                comm = parts[3]
                all_procs.append((pid, ppid, stat, comm))
            except (ValueError, IndexError):
                continue
    
    # Find descendants iteratively (may need multiple passes)
    changed = True
    while changed:
        changed = False
        for pid, ppid, stat, comm in all_procs:
            if ppid in known_pids and pid not in known_pids:
                known_pids.add(pid)
                descendants.append((pid, ppid, stat, comm))
                changed = True
    
    return descendants


def _is_foreground_process(stat: str) -> bool:
    """Check if STAT indicates a foreground process (has + flag)."""
    return '+' in stat


def _format_process_tree(process_tree: list[tuple[int, int, str, str]], pane_pid: int) -> list[str]:
    """Format process tree as ASCII tree with PIDs.
    
    Args:
        process_tree: List of (pid, ppid, stat, comm) tuples
        pane_pid: The shell's PID (root of the tree)
    
    Returns:
        List of formatted lines for the tree
    """
    if not process_tree:
        return []
    
    # Build a children map: ppid -> list of (pid, comm)
    children_map: dict[int, list[tuple[int, str]]] = {}
    for pid, ppid, stat, comm in process_tree:
        if ppid not in children_map:
            children_map[ppid] = []
        children_map[ppid].append((pid, comm))
    
    lines: list[str] = []
    
    def render_children(parent_pid: int, prefix: str, is_root: bool = False) -> None:
        """Recursively render children of a process."""
        children = children_map.get(parent_pid, [])
        for i, (pid, comm) in enumerate(children):
            is_last = (i == len(children) - 1)
            connector = "└─" if is_last else "├─"
            lines.append(f"{prefix}{connector} {comm} ({pid})")
            # For children of this process, adjust prefix
            if is_root:
                child_prefix = "   " if is_last else "│  "
            else:
                child_prefix = prefix + ("   " if is_last else "│  ")
            render_children(pid, child_prefix)
    
    # Start rendering from direct children of the shell (no initial indent)
    render_children(pane_pid, "", is_root=True)
    
    return lines


def cmd_status(args: argparse.Namespace) -> None:
    session = args.session
    _require_session(session)
    
    # Get comprehensive session and pane info
    fmt = "#{session_name}\t#{session_created}\t#{session_windows}\t#{session_attached}\t#{pane_width}\t#{pane_height}\t#{pane_pid}\t#{alternate_on}"
    res = _run_tmux(["display-message", "-p", "-t", session, fmt])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to read session info")

    parts = res.stdout.strip().split("\t")
    
    def safe_int(s: str) -> int | None:
        try:
            return int(s)
        except (ValueError, TypeError):
            return None

    name = parts[0] if len(parts) > 0 else session
    created = safe_int(parts[1]) if len(parts) > 1 else None
    windows = safe_int(parts[2]) if len(parts) > 2 else None
    attached = safe_int(parts[3]) if len(parts) > 3 else None
    width = safe_int(parts[4]) if len(parts) > 4 else None
    height = safe_int(parts[5]) if len(parts) > 5 else None
    pane_pid = safe_int(parts[6]) if len(parts) > 6 else None
    alternate_on = parts[7].strip() == "1" if len(parts) > 7 else False

    # Get shell name from pane_pid using ps
    shell_name = None
    if pane_pid:
        proc = subprocess.run(
            ["ps", "-p", str(pane_pid), "-o", "comm="],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        if proc.returncode == 0:
            shell_name = proc.stdout.strip().lstrip('-')  # Remove leading - from login shells

    # Determine state: idle or running
    state = "idle"
    foreground_command = None
    process_tree = []
    
    if pane_pid:
        process_tree = _get_process_tree(pane_pid)
        # Find foreground processes (those with + in STAT)
        foreground_procs = [(pid, ppid, stat, comm) for pid, ppid, stat, comm in process_tree
                           if _is_foreground_process(stat)]
        if foreground_procs:
            state = "running"
            # Get the deepest foreground process (last in chain)
            foreground_command = foreground_procs[-1][3] if foreground_procs else None

    print(f"Session: {name}")
    print(f"State: {state}")
    if foreground_command:
        print(f"Foreground: {foreground_command}")
    print(f"Screen: {'alternate' if alternate_on else 'normal'}")
    if width and height:
        print(f"Size: {width}x{height}")
    print(f"Locked: {'yes' if _is_locked(session) else 'no'}")
    # Show process tree with shell as root
    if pane_pid and shell_name:
        print("Processes:")
        print(f"└─ {shell_name} ({pane_pid})")
        if process_tree:
            tree_lines = _format_process_tree(process_tree, pane_pid)
            for line in tree_lines:
                print(f"   {line}")
    if windows is not None:
        print(f"Windows: {windows}")
    if attached is not None:
        print(f"Attached: {'yes' if attached else 'no'}")
    if created:
        dt = datetime.fromtimestamp(created)
        print(f"Created: {dt.strftime('%Y-%m-%d %H:%M:%S')}")

def cmd_resize(args: argparse.Namespace) -> None:
    """Resize the terminal to specified dimensions."""
    session = args.session
    _require_session(session)
    _require_unlocked(session)

    cols = args.cols
    rows = args.rows

    if cols is None and rows is None:
        raise ValueError("Must specify --cols and/or --rows")

    # Get current dimensions for any not specified
    current_cols, current_rows = _get_pane_dimensions(session)
    cols = cols if cols is not None else current_cols
    rows = rows if rows is not None else current_rows

    # Resize using resize-window
    res = _run_tmux(["resize-window", "-t", session, "-x", str(cols), "-y", str(rows)])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to resize session")
    
    print(f"Resized session '{session}' to {cols}x{rows}")

def cmd_scroll(args: argparse.Namespace) -> None:
    """Scroll the viewport up (negative) or down (positive)."""
    session = args.session
    _require_session(session)

    lines = args.lines
    if lines == 0:
        raise ValueError("Scroll lines must be non-zero")
    direction = "up" if lines < 0 else "down"
    abs_lines = abs(lines)

    # Enter copy mode and scroll
    res = _run_tmux(["copy-mode", "-t", session])
    if not res.ok:
        raise RuntimeError(res.stderr.strip() or "Failed to enter copy mode")

    # Scroll using send-keys in copy mode
    if lines < 0:
        # Scroll up
        for _ in range(abs_lines):
            _run_tmux(["send-keys", "-t", session, "-X", "scroll-up"])
    else:
        # Scroll down
        for _ in range(abs_lines):
            _run_tmux(["send-keys", "-t", session, "-X", "scroll-down"])

    print(f"Scrolled {direction} {abs_lines} lines")

def cmd_wait(args: argparse.Namespace) -> None:
    """Wait for shell prompt to appear (command completion)."""
    session = args.session
    _require_session(session)

    timeout = args.timeout if args.timeout is not None else DEFAULT_WAIT_TIMEOUT
    if timeout < 0:
        raise ValueError(f"Timeout must be non-negative, got: {timeout}")
    
    success, elapsed = _wait_for_prompt(session, timeout)
    
    if success:
        print(f"Prompt detected ({elapsed:.1f}s)")
    else:
        raise OperationTimeout(f"prompt not detected after {timeout}s")

def cmd_wait_idle(args: argparse.Namespace) -> None:
    """Wait until terminal output stops changing for a specified duration."""
    session = args.session
    _require_session(session)

    idle_seconds = args.seconds if args.seconds is not None else DEFAULT_IDLE_SECONDS
    timeout = args.timeout if args.timeout is not None else DEFAULT_IDLE_TIMEOUT
    if idle_seconds < 0:
        raise ValueError(f"Idle seconds must be non-negative, got: {idle_seconds}")
    if timeout < 0:
        raise ValueError(f"Timeout must be non-negative, got: {timeout}")
    
    success, elapsed = _wait_for_idle(session, idle_seconds, timeout)
    
    if success:
        print(f"Idle for {idle_seconds}s (waited {elapsed:.1f}s)")
    else:
        raise OperationTimeout(f"output still changing after {timeout}s")

def cmd_wait_for(args: argparse.Namespace) -> None:
    session = args.session
    _require_session(session)

    patterns = args.patterns
    timeout = args.timeout if args.timeout is not None else DEFAULT_WAIT_TIMEOUT
    ignore_case = args.ignore_case
    capture = args.capture
    
    if timeout < 0:
        raise ValueError(f"Timeout must be non-negative, got: {timeout}")
    
    start = time.time()
    poll_interval = POLL_INTERVAL_INITIAL
    
    while True:
        screen = _capture_screen(session, trim=True)
        
        for pattern in patterns:
            # Check each line for the pattern
            for line in screen.split('\n'):
                check_line = line.lower() if ignore_case else line
                check_pattern = pattern.lower() if ignore_case else pattern
                
                if check_pattern in check_line:
                    elapsed = time.time() - start
                    print(f'Pattern detected ({elapsed:.1f}s): "{pattern}"')
                    if capture:
                        print(line)
                    return
        
        elapsed = time.time() - start
        if elapsed >= timeout:
            patterns_str = '", "'.join(patterns)
            raise OperationTimeout(f'pattern not detected after {timeout}s (searched for: "{patterns_str}")')
        
        time.sleep(poll_interval)
        # Increase poll interval gradually to reduce CPU usage during long waits
        if poll_interval < POLL_INTERVAL_MAX:
            poll_interval = min(poll_interval * POLL_INTERVAL_MULTIPLIER, POLL_INTERVAL_MAX)


def _get_session_attached_count(session: str) -> int:
    """Get number of clients attached to session."""
    res = _run_tmux(["display-message", "-p", "-t", session, "#{session_attached}"])
    if res.ok:
        try:
            return int(res.stdout.strip())
        except ValueError:
            pass
    return 0


def _get_request(session: str) -> str | None:
    """Get pending request message for session, or None if no request."""
    res = _run_tmux(["show-option", "-t", session, "-qv", TERM_CLI_REQUEST_OPT])
    if res.ok and res.stdout.strip():
        return res.stdout.strip()
    return None


def _clear_request(session: str) -> None:
    """Clear pending request for session."""
    _run_tmux(["set-option", "-t", session, "-u", TERM_CLI_REQUEST_OPT])


def _get_response(session: str) -> str | None:
    """Get response message for session, or None if no response."""
    res = _run_tmux(["show-option", "-t", session, "-qv", TERM_CLI_RESPONSE_OPT])
    if res.ok and res.stdout.strip():
        return res.stdout.strip()
    return None


def _clear_response(session: str) -> None:
    """Clear response for session."""
    _run_tmux(["set-option", "-t", session, "-u", TERM_CLI_RESPONSE_OPT])


def _get_detached(session: str) -> bool:
    """Check if detached flag is set for session."""
    res = _run_tmux(["show-option", "-t", session, "-qv", TERM_CLI_DETACHED_OPT])
    return res.ok and res.stdout.strip() != ""


def _clear_detached(session: str) -> None:
    """Clear detached flag for session."""
    _run_tmux(["set-option", "-t", session, "-u", TERM_CLI_DETACHED_OPT])


def _is_locked(session: str) -> bool:
    """Check if session is locked (agent read-only mode)."""
    res = _run_tmux(["show-option", "-t", session, "-qv", TERM_CLI_LOCKED_OPT])
    return res.ok and res.stdout.strip() != ""


def _require_unlocked(session: str) -> None:
    """Raise AgentLocked if session is locked."""
    if _is_locked(session):
        raise AgentLocked(f"Session '{session}' is locked (agent read-only mode)")


def _set_locked(session: str) -> None:
    """Lock session (agent read-only mode)."""
    _run_tmux(["set-option", "-t", session, TERM_CLI_LOCKED_OPT, "1"])


def _clear_locked(session: str) -> None:
    """Unlock session."""
    _run_tmux(["set-option", "-t", session, "-u", TERM_CLI_LOCKED_OPT])


def cmd_request(args: argparse.Namespace) -> None:
    """Request human assistance on a session."""
    session = args.session
    _require_session(session)
    
    message = args.message or "Human assistance requested"
    
    # Clear any stale detached flag from previous request
    _clear_detached(session)
    
    # Store request in tmux user option (can be read via #{@term_cli_request} in format strings)
    _run_tmux(["set-option", "-t", session, TERM_CLI_REQUEST_OPT, message])
    print(f"Request stored for session '{session}'")


def cmd_request_wait(args: argparse.Namespace) -> None:
    """Wait for human to complete a request."""
    session = args.session
    _require_session(session)
    
    # Check if there's a pending request
    if not _get_request(session):
        raise ValueError(f"No pending request for session '{session}'")
    
    timeout = args.timeout if args.timeout is not None else DEFAULT_REQUEST_TIMEOUT
    if timeout < 0:
        raise ValueError(f"Timeout must be non-negative, got: {timeout}")
    
    start = time.time()
    
    while True:
        # Check if human detached without completing
        if _get_detached(session):
            _clear_detached(session)  # Clear so next request-wait can block
            elapsed = time.time() - start
            raise HumanDetached(f"term-assist detached without response ({elapsed:.1f}s)")
        
        # Check if request was cleared (completed)
        if not _get_request(session):
            # Check for response message from human
            response = _get_response(session)
            if response:
                print(f"Response: {response}")
                _clear_response(session)
            elapsed = time.time() - start
            print(f"Request completed ({elapsed:.1f}s)")
            return
        
        elapsed = time.time() - start
        if elapsed >= timeout:
            raise OperationTimeout(f"human did not respond within {timeout}s")
        
        time.sleep(1.0)


def cmd_request_cancel(args: argparse.Namespace) -> None:
    """Cancel a pending request."""
    session = args.session
    _require_session(session)
    
    if not _get_request(session):
        raise ValueError(f"No pending request for session '{session}'")
    
    _clear_request(session)
    _clear_response(session)  # Clear any lingering response too
    _clear_detached(session)  # Clear any detached flag too
    print(f"Cancelled request for session '{session}'")


def cmd_request_status(args: argparse.Namespace) -> None:
    """Check if a request is pending."""
    session = args.session
    _require_session(session)
    
    request = _get_request(session)
    if request:
        print("pending")
    else:
        raise QueryResult("none")


# ----------------------------
# CLI
# ----------------------------

def build_parser() -> argparse.ArgumentParser:
    cols_default, rows_default = _size_defaults()

    p = argparse.ArgumentParser(
        prog="term-cli",
        description="""Non-interactive terminal session control for AI agents (tmux wrapper).

Requires: tmux on PATH

Use 'term-cli <command> -h' for command-specific help.

Exit codes: 0=success, 1=runtime error, 2=invalid input, 3=timeout, 4=detached, 5=locked, 127=tmux not found

tmux keys: C-c C-d C-u C-z (ctrl), Enter Escape Space Tab BSpace, Up Down Left Right, Home End NPage PPage, F1-F12""",
        epilog="""Examples:
  term-cli start --session build --cwd /path/to/project
  term-cli run --session build "make test" --wait --timeout 60
  term-cli capture --session build
  term-cli send-key --session build C-c
  term-cli wait --session build --timeout 10
  term-cli kill --session build

Short forms (commands and flags can be abbreviated):
  term-cli send-t -s b ":wq" -e      # send-text --session b ":wq" --enter
  term-cli wait-i -s b -i 3 -t 5     # wait-idle --session b --seconds 3 --timeout 5

Note: Use single quotes for -m messages with shell special chars: -m 'Done! $var'""",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    
    # Global options (before subcommands)
    p.add_argument("-L", "--socket-name", metavar="NAME",
                   help="Use a different tmux socket (for isolated servers)")
    
    sub = p.add_subparsers(dest="cmd", required=False, metavar="<command>")

    # list
    sp = sub.add_parser("list", help="List sessions")
    sp.set_defaults(func=cmd_list)

    # start
    sp = sub.add_parser("start", help="Create session (fails if exists)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-c", "--cwd", metavar="DIR", help="Working directory")
    sp.add_argument("-x", "--cols", type=int, metavar="N", help=f"Width (default: {cols_default})")
    sp.add_argument("-y", "--rows", type=int, metavar="N", help=f"Height (default: {rows_default})")
    sp.add_argument("-e", "--env", action="append", default=[], metavar="K=V", help="Set env var (repeatable)")
    sp.add_argument("--shell", metavar="CMD", help="Shell command (default: user shell)")
    sp.add_argument("--no-size", action="store_true", help="Let tmux decide size")
    sp.add_argument("-l", "--locked", action="store_true", help="Start locked (agent read-only)")
    sp.set_defaults(func=cmd_start)

    # kill
    sp = sub.add_parser("kill", help="Kill session (fails if not exists)")
    sp.add_argument("-s", "--session", metavar="NAME", help="Session name")
    sp.add_argument("-a", "--all", action="store_true", help="Kill all sessions")
    sp.add_argument("-f", "--force", action="store_true", help="Kill even if humans attached")
    sp.set_defaults(func=cmd_kill)

    # run
    sp = sub.add_parser("run", help="Run command (send + Enter)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("command", metavar="CMD", help="Command to run")
    sp.add_argument("-w", "--wait", action="store_true", help="Wait for prompt")
    sp.add_argument("-t", "--timeout", type=float, metavar="SEC", help=f"Wait timeout (default: {DEFAULT_WAIT_TIMEOUT})")
    sp.set_defaults(func=cmd_run)

    # send-text
    sp = sub.add_parser("send-text", help="Send text (no Enter unless --enter)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("text", help="Text to send")
    sp.add_argument("-e", "--enter", action="store_true", help="Send Enter after")
    sp.set_defaults(func=cmd_send_text)

    # send-key
    sp = sub.add_parser("send-key", help="Send tmux key (C-c, Enter, Up, ...)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("key", help="Key (tmux notation)")
    sp.set_defaults(func=cmd_send_key)

    # capture
    sp = sub.add_parser("capture", help="Capture screen (visible, trimmed)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-n", "--scrollback", type=int, metavar="N",
                    help="Last N logical lines from scrollback+visible history (joins wrapped lines)")
    sp.add_argument("-t", "--tail", type=int, metavar="N",
                    help="Last N physical rows from bottom of visible screen")
    sp.add_argument("-r", "--raw", action="store_true", help="Include ANSI escape codes (colors)")
    sp.add_argument("--no-trim", action="store_true", help="Keep trailing whitespace")
    sp.set_defaults(func=cmd_capture)

    # pipe-log
    sp = sub.add_parser("pipe-log", help="Stream to file (escapes stripped)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("file", metavar="PATH", help="Log file")
    sp.add_argument("-r", "--raw", action="store_true", help="Keep ANSI escapes")
    sp.set_defaults(func=cmd_pipe_log)

    # unpipe
    sp = sub.add_parser("unpipe", help="Stop streaming to file")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.set_defaults(func=cmd_unpipe)

    # send-stdin
    sp = sub.add_parser("send-stdin", help="Send stdin content to session")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.set_defaults(func=cmd_send_stdin)

    # status (replaces old 'info' command)
    sp = sub.add_parser("status", help="Show session status (idle/running, process tree)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.set_defaults(func=cmd_status)

    # resize
    sp = sub.add_parser("resize", help="Resize terminal")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-x", "--cols", type=int, metavar="N", help="New width")
    sp.add_argument("-y", "--rows", type=int, metavar="N", help="New height")
    sp.set_defaults(func=cmd_resize)

    # scroll
    sp = sub.add_parser("scroll", help="Scroll viewport (negative=up)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("lines", type=int, metavar="N", help="Lines (negative=up)")
    sp.set_defaults(func=cmd_scroll)

    # wait
    sp = sub.add_parser("wait", help="Wait for prompt")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-t", "--timeout", type=float, metavar="SEC", help=f"Timeout (default: {DEFAULT_WAIT_TIMEOUT})")
    sp.set_defaults(func=cmd_wait)

    # wait-idle
    sp = sub.add_parser("wait-idle", help="Wait for output to stop")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-i", "--seconds", type=float, metavar="SEC", help=f"Idle time (default: {DEFAULT_IDLE_SECONDS})")
    sp.add_argument("-t", "--timeout", type=float, metavar="SEC", help=f"Max wait (default: {DEFAULT_IDLE_TIMEOUT})")
    sp.set_defaults(func=cmd_wait_idle)

    # wait-for
    sp = sub.add_parser("wait-for", help="Wait for pattern in output")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("patterns", nargs="+", metavar="PATTERN", help="Pattern(s) to wait for (first match wins)")
    sp.add_argument("-t", "--timeout", type=float, metavar="SEC", help=f"Timeout (default: {DEFAULT_WAIT_TIMEOUT})")
    sp.add_argument("-i", "--ignore-case", action="store_true", help="Case-insensitive matching")
    sp.add_argument("-c", "--capture", action="store_true", help="Also print the matched line")
    sp.set_defaults(func=cmd_wait_for)

    # request
    sp = sub.add_parser("request", help="Request human assistance")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-m", "--message", metavar="MSG", help="Message for human (shown in status bar)")
    sp.set_defaults(func=cmd_request)

    # request-wait
    sp = sub.add_parser("request-wait", help="Wait for human to complete request")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.add_argument("-t", "--timeout", type=float, metavar="SEC", help=f"Timeout (default: {DEFAULT_REQUEST_TIMEOUT})")
    sp.set_defaults(func=cmd_request_wait)

    # request-cancel
    sp = sub.add_parser("request-cancel", help="Cancel pending request")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.set_defaults(func=cmd_request_cancel)

    # request-status
    sp = sub.add_parser("request-status", help="Check if request is pending (exit 0=pending, 1=none)")
    sp.add_argument("-s", "--session", required=True, metavar="NAME", help="Session name")
    sp.set_defaults(func=cmd_request_status)

    return p

# All valid command names for prefix matching
COMMANDS = [
    "list", "start", "kill", "run", "send-text", "send-key", "send-stdin",
    "capture", "pipe-log", "unpipe", "status", "resize", "scroll",
    "wait", "wait-idle", "wait-for",
    "request", "request-wait", "request-cancel", "request-status",
]

def _expand_command(cmd: str) -> str:
    """Expand abbreviated command to full name if unambiguous."""
    if cmd in COMMANDS:
        return cmd
    matches = [c for c in COMMANDS if c.startswith(cmd)]
    if len(matches) == 1:
        return matches[0]
    if len(matches) > 1:
        raise ValueError(f"Ambiguous command '{cmd}': could be {', '.join(sorted(matches))}")
    return cmd  # Let argparse handle unknown command error

def main(argv: list[str] | None = None) -> int:
    global _tmux_socket
    
    parser = build_parser()
    
    # Expand abbreviated commands before parsing
    # Handle global options like -L/--socket-name that come before the command
    if argv is None:
        argv = sys.argv[1:]
    argv = list(argv)  # Make a mutable copy
    
    # Find the command (first non-option argument)
    skip_next = False
    for i, arg in enumerate(argv):
        if skip_next:
            skip_next = False
            continue
        if arg.startswith("-"):
            # Skip option and its value if it takes one
            if arg in ("-L", "--socket-name"):
                skip_next = True
            continue
        # Found a command - try to expand it
        try:
            argv[i] = _expand_command(arg)
        except ValueError as e:
            _eprint(f"Error: {e}")
            return EXIT_INPUT_ERROR
        break
    
    args = parser.parse_args(argv)
    
    # Set global socket name if provided
    if hasattr(args, 'socket_name') and args.socket_name:
        _tmux_socket = args.socket_name

    # Show help if no command given
    if args.cmd is None:
        parser.print_help()
        return EXIT_SUCCESS

    try:
        args.func(args)
        return EXIT_SUCCESS

    except FileNotFoundError as e:
        _eprint(f"Error: {e}")
        return EXIT_NOT_FOUND

    except ValueError as e:
        _eprint(f"Error: {e}")
        return EXIT_INPUT_ERROR

    except OperationTimeout as e:
        _eprint(f"Timeout: {e}")
        return EXIT_TIMEOUT

    except HumanDetached as e:
        # Not an error per se - print message to stdout, return exit 4
        print(str(e))
        return EXIT_DETACHED

    except AgentLocked as e:
        _eprint(f"Error: {e}")
        return EXIT_LOCKED

    except QueryResult as e:
        # Not an error - normal query result printed to stdout, specific exit code
        print(str(e))
        return e.exit_code

    except RuntimeError as e:
        _eprint(f"Error: {e}")
        return EXIT_RUNTIME_ERROR


if __name__ == "__main__":
    raise SystemExit(main())
